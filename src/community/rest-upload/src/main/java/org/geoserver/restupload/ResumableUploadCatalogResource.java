/* (c) 2014-2015 Open Source Geospatial Foundation - all rights reserved
 * This code is licensed under the GPL 2.0 license, available at the root
 * application directory.
 */

package org.geoserver.restupload;

import java.util.logging.Level;
import java.util.logging.Logger;

import org.apache.commons.lang.StringUtils;
import org.geoserver.catalog.Catalog;
import org.geoserver.rest.util.RESTUtils;
import org.geotools.util.logging.Logging;
import org.restlet.Context;
import org.restlet.data.Form;
import org.restlet.data.MediaType;
import org.restlet.data.Parameter;
import org.restlet.data.Request;
import org.restlet.data.Response;
import org.restlet.data.Status;
import org.restlet.resource.Representation;
import org.restlet.resource.Resource;
import org.restlet.resource.StringRepresentation;
import org.restlet.util.Series;

public class ResumableUploadCatalogResource extends Resource {

    private static final Logger LOGGER = Logging.getLogger(ResumableUploadCatalogResource.class);

    private ResumableUploadResourceManager resumableUploadResourceManager;

    /**
     * If the server has succesfully received all bytes from the operation, it responds with a final status code; otherwise it responds with a 308
     * (Resume Incomplete), indicating which bytes of the operation it has successfully received.
     */
    public static final Status RESUME_INCOMPLETE = new Status(308);

    public ResumableUploadCatalogResource(Context context, Request request, Response response,
            Catalog catalog, ResumableUploadResourceManager resumableUploadResourceManager) {
        super(context, request, response);
        this.resumableUploadResourceManager = resumableUploadResourceManager;
    }

    @Override
    public boolean allowPost() {
        return true;
    }

    @Override
    public boolean allowPut() {
        return resumableUploadResourceManager.existsUploads();
    }

    @Override
    public boolean allowGet() {
        return resumableUploadResourceManager.existsUploads();
    }

    @Override
    /*
     * First POST request returns upload URL with uploadId to call with successive PUT request
     */
    public void handlePost() {
        String uploadId = resumableUploadResourceManager.createUploadResource();
        Representation output = new StringRepresentation(uploadId, MediaType.TEXT_PLAIN);
        Response response = getResponse();
        response.setEntity(output);
        response.setStatus(Status.SUCCESS_CREATED);
    }

    /*
     * PUT request is used to uploads file with uploadId generated by POST request
     */
    @Override
    public void handlePut() {
        /*
         * Check required parameters: - uploadId - Content-Length
         */
        String uploadId = RESTUtils.getAttribute(getRequest(), "uploadId");
        if (uploadId == null || uploadId.isEmpty()) {
            getResponse().setStatus(
                    new Status(Status.CLIENT_ERROR_BAD_REQUEST, "Missing upload ID"));
            return;
        }
        if (!resumableUploadResourceManager.existsUpload(uploadId)) {
            getResponse()
            .setStatus(new Status(Status.CLIENT_ERROR_BAD_REQUEST, "Unknow upload ID"));
            return;
        }
        Long totalByteToUpload = getContentLength();
        Long startPosition = 0L;
        Long endPosition = (totalByteToUpload - 1);
        Long totalFileSize = totalByteToUpload;
        if (totalByteToUpload == 0) {
            getResponse().setStatus(
                    new Status(Status.CLIENT_ERROR_LENGTH_REQUIRED,
                            "Not zero Content-Length header must be specified"));
            return;
        }
        String contentRange = getContentRange();
        if (!contentRange.isEmpty()) {
            try {
                String range = contentRange.substring(6);
                String[] rangeParts = range.split("/");
                startPosition = Long.parseLong(rangeParts[0].split("-")[0]);
                endPosition = Long.parseLong(rangeParts[0].split("-")[1]);
                totalFileSize = Long.parseLong(rangeParts[1]);
                if (startPosition > endPosition
                        || ((endPosition - startPosition) != totalByteToUpload)) {
                    getResponse().setStatus(Status.CLIENT_ERROR_BAD_REQUEST);
                    return;
                }
                /*
                 * Validate resume request If resume is requested existing file must contains the number of bytes matching startPosition
                 */
                Boolean validated = resumableUploadResourceManager.validateUpload(uploadId,
                        totalByteToUpload, startPosition, endPosition, totalFileSize);
                if (!validated) {
                    getResponse().setStatus(Status.CLIENT_ERROR_REQUESTED_RANGE_NOT_SATISFIABLE);
                    return;
                }
            } catch (Exception e) {
                LOGGER.log(Level.SEVERE, e.getMessage(), e);
                getResponse().setStatus(Status.CLIENT_ERROR_BAD_REQUEST);
                return;
            }
        } else {
            // First upload request, save file size
            resumableUploadResourceManager.setFileSize(uploadId, totalFileSize);
            // Delete previous file if exists
            resumableUploadResourceManager.clearUpload(uploadId);
        }

        /*
         * Start upload
         */
        Long writedBytes = resumableUploadResourceManager.handleUpload(uploadId, getRequest()
                .getEntity(), startPosition);
        if (writedBytes < resumableUploadResourceManager.getFileSize(uploadId)) {
            getResponse().setStatus(new Status(RESUME_INCOMPLETE.getCode()));
            Series<Parameter> headers = new Form();
            headers.add("Content-Length", "0");
            headers.add("Range", "0-" + (writedBytes - 1));
            getResponse().getAttributes().put("org.restlet.http.headers", headers);
        } else {
            Representation output = new StringRepresentation("resturl", MediaType.TEXT_PLAIN);
            Response response = getResponse();
            response.setEntity(output);
            response.setStatus(Status.SUCCESS_OK);
            resumableUploadResourceManager.uploadDone(uploadId);
        }

    }

    /*
     * GET request with uploadId is used to get the status of upload
     */
    @Override
    public void handleGet() {
        String uploadId = RESTUtils.getAttribute(getRequest(), "uploadId");
        if (uploadId == null || uploadId.isEmpty()) {
            getResponse().setStatus(
                    new Status(Status.CLIENT_ERROR_BAD_REQUEST, "Missing upload ID"));
            return;
        }
        if (!resumableUploadResourceManager.existsUpload(uploadId)) {
            getResponse()
            .setStatus(new Status(Status.CLIENT_ERROR_BAD_REQUEST, "Unknow upload ID"));
            return;
        }
        Long writedBytes = resumableUploadResourceManager.getWritedBytes(uploadId);
        if (writedBytes < resumableUploadResourceManager.getFileSize(uploadId)) {
            getResponse().setStatus(new Status(RESUME_INCOMPLETE.getCode()));
            Series<Parameter> headers = new Form();
            headers.add("Content-Length", "0");
            headers.add("Range", "0-" + (writedBytes - 1));
            getResponse().getAttributes().put("org.restlet.http.headers", headers);
        } else {
            Representation output = new StringRepresentation("resturl", MediaType.TEXT_PLAIN);
            Response response = getResponse();
            response.setEntity(output);
            response.setStatus(Status.SUCCESS_OK);
            resumableUploadResourceManager.uploadDone(uploadId);
        }
    }

    private Long getContentLength() {
        Long contentLength = 0L;
        Object oHeaders = getRequest().getAttributes().get("org.restlet.http.headers");
        if (oHeaders != null) {
            Series<Parameter> headers = (Series<Parameter>) oHeaders;
            Parameter contentLengthParam = headers.getFirst("Content-Length", true);
            if (contentLengthParam != null) {
                String contentLengthStr = contentLengthParam.getValue();
                if (!contentLengthStr.isEmpty() && StringUtils.isNumeric(contentLengthStr)) {
                    contentLength = Long.parseLong(contentLengthStr);
                }
            }
        }
        return contentLength;
    }

    private String getContentRange() {
        String contentRange = "";
        Object oHeaders = getRequest().getAttributes().get("org.restlet.http.headers");
        if (oHeaders != null) {
            Series<Parameter> headers = (Series<Parameter>) oHeaders;
            Parameter contentRangeParam = headers.getFirst("Content-Range", true);
            if (contentRangeParam != null) {
                contentRange = contentRangeParam.getValue();
            }
        }
        return contentRange;
    }

}
